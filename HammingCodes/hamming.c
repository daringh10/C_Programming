#include "hamming.h"

#include "bm.h"

#include <stdio.h>
#include <stdlib.h>


//A look up table for the numbers represented in the
//correct row from the matrix H transpose. If the syndrome
//Vector is any of these values than the error can be corrected.
int look_up_table[8] = { 14, 13, 11, 7, 1, 2, 4, 8 };



//Initialize G and H matrixes as null
static BitMatrix *G = NULL;
static BitMatrix *H = NULL;

//Creates the Bit Matrixes G and H.
//Iterates through the 2 matrices and sets the correct values of 1 and 0
//with bm_set_bit.
ham_rc ham_init(void) {

    G = bm_create(4, 8);
    H = bm_create(8, 4);

    if (G == NULL || H == NULL) {
        return HAM_ERR;
    }
//Loops for setting the matrices
    for (uint8_t i = 0; i < bm_rows(G); i++) {
        for (uint8_t j = 0; j < bm_cols(G); j++) {

            if (j < 4) {
                if (i == j) {
                    bm_set_bit(G, i, j);
                }
            }

            else {
                if ((i) == (j - 4)) {
                    continue;
                }

                else {
                    bm_set_bit(G, i, j);
                }
            }
        }
    }
//Loops for setting the matrices
    for (uint8_t i = 0; i < bm_rows(H); i++) {
        for (uint8_t j = 0; j < bm_cols(H); j++) {

            if (i < 4) {
                if (i == j) {
                    continue;
                }

                else {
                    bm_set_bit(H, i, j);
                }
            }

            else {
                if ((i - 4) == j) {
                    bm_set_bit(H, i, j);
                }

                else {
                    continue;
                }
            }
        }
    }

    return HAM_OK;
}


//Deletes Matrices G and H.
void ham_destroy(void) {
    bm_delete(&G);
    bm_delete(&H);
}


//Creates the 8 bit code generated by multiply a nibble of  data by
//the matrix G.
ham_rc ham_encode(uint8_t data, uint8_t *code) {

    if (code == NULL) {
        return HAM_ERR;
    }

    uint8_t temp = 0;
    *code = 0x00; // binary number

    for (uint8_t x = 0; x < bm_cols(G); x++) {
        for (uint8_t i = 0; i < 4; i++) {
            temp += ((((0x1 << i) & data) >> i) & bm_get_bit(G, i, x));
        }
        *code = *code | ((temp % 2) << x);

        temp = 0x00;
    }

    return HAM_OK;
}


//Multiples the codeword from ham_encode() by the matrix H to create a syndrome
//vector. That vector will determine if there was 0, 1 or more than 1 error.
ham_rc ham_decode(uint8_t code, uint8_t *data) {

    uint8_t temp = 0;
    *data = 0x00; // binary number

    for (uint8_t x = 0; x < bm_cols(H); x++) {
        for (uint8_t i = 0; i < 8; i++) {
            temp += ((((0x1 << i) & code) >> i) & bm_get_bit(H, i, x));
        }

        *data = *data | ((temp % 2) << x);
        temp = 0x00;
    }

    if (*data == 0) {
        *data = (code);
        return HAM_OK;
    }

    for (uint8_t i = 0; i < 8; i++) {

        if (*data == look_up_table[i]) {
            code = code ^ (0x01 << i);
            *data = (code);
            return HAM_ERR_OK;
        }
    }

    return HAM_ERR;
}



